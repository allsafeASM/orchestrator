"""
Vulnerability Scan Orchestrator
Handles vulnerability scanning with nuclei, including progress tracking and status updates
"""
import logging
import traceback
import azure.durable_functions as df
import azure.functions as func
from config.task_registry import get_task_sequence
from config.scan_context import ScanContext

app = func.Blueprint()

@app.orchestration_trigger(context_name="context")
def vulnerability_scan_orchestrator(context: df.DurableOrchestrationContext):
    logging.info("=== VULNERABILITY SCAN ORCHESTRATOR STARTED ===")
    try:
        initial_input = context.get_input()
        scan_context = ScanContext.from_dict(initial_input["scan_context"])
        parent_instance_id = context.instance_id
        
        # Define vulnerability task sequence (only nuclei for now)
        vuln_task_sequence = ["nuclei"]
        
        logging.info(f"Vulnerability scan config: vuln_scan_id={scan_context.vuln_scan_id}, domain={scan_context.domain}, tasks={vuln_task_sequence}")
        
        # Get configurations for vulnerability tasks
        task_configs = get_task_sequence(vuln_task_sequence)
        if not task_configs:
            raise ValueError(f"No valid task configurations found for vulnerability sequence: {vuln_task_sequence}")
        
        results = []
        total_completion_events = 0
        expected_completion_events = 0
        
        # Execute vulnerability tasks sequentially
        for i, task_config in enumerate(task_configs):
            task_name = task_config.task_name
            status_description = task_config.description
            logging.info(f"Starting vulnerability task {i+1}/{len(task_configs)}: {task_name}")
            
            # Update vulnerability scan status before running the task
            yield context.call_activity(
                "update_vulnerability_scan_status",
                {
                    "vulnerability_scan_id": scan_context.vuln_scan_id,
                    "status": f"In Progress"
                }
            )
            
            # Create task-specific configuration
            task_execution_config = {
                "scan_context": scan_context.to_dict(),
                "instance_id": f"{parent_instance_id}-{scan_context.vuln_scan_id}-{task_name}",
                "task": task_name,
                "task_index": i,
                "total_tasks": len(task_configs)
            }
            
            # Note: nuclei uses its own special input paths (network and http) handled in nuclei_progress_orchestrator
            logging.info(f"Task {task_name} will use special nuclei input paths")
            
            # Add task-specific parameters
            task_dict = task_config.to_dict()
            for key, value in task_dict.items():
                if key not in ["task_name", "description", "input_blob_path"]:  # Skip metadata fields
                    task_execution_config[key] = value
            
            # Execute nuclei with progress tracking
            nuclei_result = yield context.call_sub_orchestrator(
                "nuclei_progress_orchestrator",
                task_execution_config,
                instance_id=task_execution_config["instance_id"]
            )
            
            total_completion_events = nuclei_result.get("total_completion_events", 0)
            expected_completion_events = nuclei_result.get("expected_completion_events", 0)
            
            results.append({
                "task": task_name,
                "result_path": nuclei_result.get("aggregated_result"),
                "status": "completed",
                "total_completion_events": total_completion_events,
                "expected_completion_events": expected_completion_events
            })
            
            logging.info(f"Completed vulnerability task {task_name}")

        # After all vulnerability tasks are done, store the final vulnerability scan results
        nuclei_blob_path = f"scans/{scan_context.domain}-{scan_context.vuln_scan_id}/nuclei/out/final_out.json"

        yield context.call_activity(
            "save_vulnerability_scan_results",
            {
                "scan_context": scan_context.to_dict(),
                "nuclei_blob_path": nuclei_blob_path
            }
        )

        # Create final vulnerability scan summary
        vuln_scan_summary = {
            "vuln_scan_id": scan_context.vuln_scan_id,
            "domain": scan_context.domain,
            "status": "completed",
            "total_tasks": len(task_configs),
            "completed_tasks": len(results),
            "task_results": results,
            "total_completion_events": total_completion_events,
            "expected_completion_events": expected_completion_events
        }
        
        logging.info(f"=== VULNERABILITY SCAN ORCHESTRATOR COMPLETED === {vuln_scan_summary}")

        # Update final vulnerability scan status
        yield context.call_activity(
            "update_vulnerability_scan_status",
            {"vulnerability_scan_id": scan_context.vuln_scan_id, "status": "Completed"}
        )

        return vuln_scan_summary
        
    except Exception as e:
        logging.error(f"Vulnerability scan orchestrator failed: {str(e)}")
        logging.error(traceback.format_exc())
        raise 